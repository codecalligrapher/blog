<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>python on Aadi</title>
    <link>https://aadi-blogs.web.app/tags/python/</link>
    <description>Recent content in python on Aadi</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Â©2022 {year}</copyright>
    <lastBuildDate>Thu, 08 Dec 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://aadi-blogs.web.app/tags/python/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>XGBoost Evaluation Classes</title>
      <link>https://aadi-blogs.web.app/code/xgboost-eval/</link>
      <pubDate>Thu, 08 Dec 2022 00:00:00 +0000</pubDate>
      
      <guid>https://aadi-blogs.web.app/code/xgboost-eval/</guid>
      <description>false</description>
    </item>
    
    <item>
      <title>XGBoost, Imbalanced Classification and Hyperopt</title>
      <link>https://aadi-blogs.web.app/blog/hyperparamtuning/</link>
      <pubDate>Tue, 06 Dec 2022 06:38:42 -0400</pubDate>
      
      <guid>https://aadi-blogs.web.app/blog/hyperparamtuning/</guid>
      <description>This is a tutorial/explanation of how to set up XGBoost for imbalanced classification while tuning for imbalanced data.
There are three main sections:
Hyperopt/Bayesian Hyperparameter Tuning Focal and Crossentropy losses XGBoost Parameter Meanings (references are dropped as-needed)
Hyperopt The hyperopt package is associated with Bergstra et. al.. The authors argued that the performance of a given model depends both on the fundamental quality of the algorithm as well as details of its tuning (also known as its hyper-parameters).</description>
    </item>
    
    <item>
      <title>Enforcing Function Implementation in Subclasses</title>
      <link>https://aadi-blogs.web.app/blog/enforce-override/</link>
      <pubDate>Wed, 09 Nov 2022 12:38:42 -0400</pubDate>
      
      <guid>https://aadi-blogs.web.app/blog/enforce-override/</guid>
      <description>This is going to get very weird, very quickly. When you create a class in Python, it looks about like the following:
class MyClass: pass Now, let&amp;rsquo;s say I create some really cool class, with a set of cool functions, but I expect my users to implement some of the functions:
from abc import abstractmethod class BaseClass: @abstractmethod def foo(self,): raise NotImplementedError So the intention is, when my user inherits the above class, they do the following:</description>
    </item>
    
    <item>
      <title>Managed Attributes in Python</title>
      <link>https://aadi-blogs.web.app/blog/metaprogramming-in-data-science/</link>
      <pubDate>Sat, 05 Nov 2022 00:38:42 -0400</pubDate>
      
      <guid>https://aadi-blogs.web.app/blog/metaprogramming-in-data-science/</guid>
      <description>In a previous post, I detailed how to maintain encapsulation using Python&amp;rsquo;s property. In this piece, I go through how/why to manage and apply validation to class attributes in an object-oriented fashion by means of a fairly plausible example.
A type is the parent class of class, therefore any class is actually a sub-type of type. The following are equivalent:
a = int(8) a = 8 type(a) # python knows to create an int without being explicit int The point of implementing custom attribute types is (in my case), for validation.</description>
    </item>
    
  </channel>
</rss>
